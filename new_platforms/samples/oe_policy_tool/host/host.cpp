// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#include <openenclave/host.h>
#include <stdio.h>

#include <algorithm>
#include <array>
#include <fstream>
#include <functional>
#include <json11.hpp>
#include <memory>
#include <set>
#include <string>
#include <vector>

#ifdef LINUX
#include <dirent.h>
#endif

// Include the untrusted oe_policy_tool header that is generated
// during the build. This file is generated by calling the
// sdk tool sgx_edger8r against the oe_policy_tool.edl file.
#include "oe_policy_tool_u.h"

#define COMMAND_HARVEST "-harvest"
#define COMMAND_COMPOSE "-compose"

#define CLAIM_DEVICE "device"
#define CLAIM_DEVICE_PUBLIC_KEY "device_public_key"
#define CLAIM_EXPECTED_COMPONENTS "expected_components"
#define CLAIM_ISSUE_TOKEN "issue_token"
#define CLAIM_TEE "tee"
#define CLAIM_PREFIX_COMPONENT "component_"
#define CLAIM_SUFFIX_ID "_id"
#define CLAIM_VALUE_OK "ok"

#ifdef WIN32
#define PEM_FILES "\\*.pem"
#endif

#ifndef EOTHER
#define EOTHER 131
#endif

void usage(int argc, const char* argv[])
{
    printf(
        "usage: %s <switch>\n\nswitches:\n"
        "%s <output-path>\t\t\t\t extracts CyReS certificate chain for the "
        "current "
        "device\n"
        "%s <source-directory> <output-path>\t generates attestation policy "
        "based on given CyReS certificate chains\n"
        "\n",
        argc >= 1 ? argv[0] : "harvesttcs",
        COMMAND_HARVEST,
        COMMAND_COMPOSE);
}

template <typename A>
struct final_action
{ // slightly simplified
    A act;
    final_action(A a) : act{a}
    {
    }
    ~final_action()
    {
        act();
    }
};

template <typename A>
final_action<A> finally(A act) // deduce action type
{
    return final_action<A>{act};
}

static std::string HexString(
    _In_ const uint8_t* buffer,
    _In_ const size_t buffer_size)
{
    static constexpr char hexMap[] = {'0',
                                      '1',
                                      '2',
                                      '3',
                                      '4',
                                      '5',
                                      '6',
                                      '7',
                                      '8',
                                      '9',
                                      'a',
                                      'b',
                                      'c',
                                      'd',
                                      'e',
                                      'f'};
    std::string output(buffer_size * 2, ' ');

    for (uint32_t i = 0; i < buffer_size; i++)
    {
        output[2 * i] = hexMap[(buffer[i] & 0xF0) >> 4];
        output[2 * i + 1] = hexMap[buffer[i] & 0x0F];
    }

    return output;
}

void extract_hashes_and_dpks(
    const std::vector<oe_report_t>& reports,
    std::vector<std::set<std::array<uint8_t, OE_UNIQUE_ID_SIZE>>>& hashes,
    std::set<std::array<uint8_t, OE_ECC_PUBLIC_KEY_SIZE>>& device_public_keys)
{
    for (const auto& report : reports)
    {
        const oe_identity_t* identity = &report.identity;
        size_t identity_index = 0;

        while (identity != NULL)
        {
            if (hashes.size() <= identity_index)
            {
                hashes.push_back({});
            }

            identity_index++;
            identity = identity->caller;
        }

        const size_t identity_count = identity_index;
        identity_index = 0;
        identity = &report.identity;

        while (identity != NULL)
        {
            identity_index++;
            auto& hashes_current = hashes[identity_count - identity_index];

            std::array<uint8_t, OE_UNIQUE_ID_SIZE> uid;
            std::copy_n(identity->unique_id, uid.size(), uid.begin());
            hashes_current.insert(uid);

            if (identity->caller == NULL)
            {
                std::array<uint8_t, OE_ECC_PUBLIC_KEY_SIZE> public_key;
                std::copy_n(
                    identity->public_key,
                    public_key.size(),
                    public_key.begin());
                device_public_keys.insert(public_key);
            }

            identity = identity->caller;
        }
    }
}

void generate_policy_json(
    const std::vector<oe_report_t> reports,
    const std::string& output_path)
{
    std::vector<std::set<std::array<uint8_t, OE_UNIQUE_ID_SIZE>>> hashes;
    std::set<std::array<uint8_t, OE_ECC_PUBLIC_KEY_SIZE>> device_public_keys;

    extract_hashes_and_dpks(reports, hashes, device_public_keys);

    json11::Json::object policy;

    // mandatory attributes
    policy["$version"] = json11::Json(1);
    policy["$allow-debuggable"] = json11::Json(true);

    // list of expected claims
    json11::Json::array issued_claims{
        json11::Json(CLAIM_DEVICE_PUBLIC_KEY),
        json11::Json(CLAIM_DEVICE),
        json11::Json(CLAIM_EXPECTED_COMPONENTS),
        json11::Json(CLAIM_ISSUE_TOKEN),
        json11::Json(CLAIM_TEE),
    };
    for (size_t i = 0; i < hashes.size(); i++)
    {
        issued_claims.push_back(
            json11::Json(CLAIM_PREFIX_COMPONENT + std::to_string(i)));
        issued_claims.push_back(json11::Json(
            CLAIM_PREFIX_COMPONENT + std::to_string(i) + CLAIM_SUFFIX_ID));
    }
    policy["$claims"] = issued_claims;

    // claim definitions
    policy[CLAIM_DEVICE_PUBLIC_KEY] = json11::Json("$public_key_0");

    json11::Json::array expected_device_public_keys;
    for (const auto& pubk_buffer : device_public_keys)
    {
        expected_device_public_keys.push_back(
            json11::Json(HexString(&pubk_buffer.front(), pubk_buffer.size())));
    }
    json11::Json::object dpk_ok_object;
    dpk_ok_object[CLAIM_DEVICE_PUBLIC_KEY] = expected_device_public_keys;
    json11::Json::object dpk_ok;
    dpk_ok[CLAIM_VALUE_OK] = dpk_ok_object;
    policy[CLAIM_DEVICE] = dpk_ok;

    // expected components claim
    json11::Json::array expected_components;
    json11::Json::object identity;
    identity["$tee"] = json11::Json("cyres");
    for (size_t i = 0; i < hashes.size(); i++)
    {
        json11::Json::object expected_component;
        expected_component[CLAIM_PREFIX_COMPONENT + std::to_string(i)] =
            identity;
        expected_components.push_back(expected_component);
    }
    policy[CLAIM_EXPECTED_COMPONENTS] = expected_components;

    // issue token claim
    json11::Json ok(CLAIM_VALUE_OK);
    json11::Json::object issue_token_ok;
    issue_token_ok[CLAIM_DEVICE] = ok;
    for (size_t i = 0; i < hashes.size(); i++)
    {
        issue_token_ok[CLAIM_PREFIX_COMPONENT + std::to_string(i)] = ok;
    }
    json11::Json::object issue_token;
    issue_token[CLAIM_VALUE_OK] = issue_token_ok;
    policy[CLAIM_ISSUE_TOKEN] = issue_token;

    // tee claim
    policy[CLAIM_TEE] = json11::Json("$tee");

    // component_<n>_id claims
    for (size_t i = 0; i < hashes.size(); i++)
    {
        policy[CLAIM_PREFIX_COMPONENT + std::to_string(i) + CLAIM_SUFFIX_ID] =
            json11::Json("$unique_id_" + std::to_string(i));
    }

    // component_<n> and component
    for (size_t i = 0; i < hashes.size(); i++)
    {
        const auto& current_hashes = hashes[i];
        json11::Json::array expected_hashes;
        for (const auto& hash : current_hashes)
        {
            expected_hashes.push_back(
                json11::Json(HexString(&hash.front(), hash.size())));
        }

        json11::Json::object componentid;
        componentid
            [CLAIM_PREFIX_COMPONENT + std::to_string(i) + CLAIM_SUFFIX_ID] =
                expected_hashes;

        json11::Json::object component_ok;
        component_ok[CLAIM_VALUE_OK] = componentid;

        policy[CLAIM_PREFIX_COMPONENT + std::to_string(i)] = component_ok;
    }

    {
        std::ofstream policyfile(output_path);
        if (!policyfile)
        {
            throw EOTHER;
        }
        policyfile << json11::Json(policy).dump();
    }
}

void harvest_report(const std::string& output_path)
{
    oe_result_t result;
    oe_enclave_t* enclave = NULL;

    // Create the enclave
    result = oe_create_oe_policy_tool_enclave(
        "97d140f8-5f59-4d1f-9735-cb21d49e7eb6",
        OE_ENCLAVE_TYPE_UNDEFINED,
        0,
        NULL,
        0,
        &enclave);
    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "oe_create_enclave(): result=%u (%s)\n",
            result,
            oe_result_str(result));
        throw EOTHER;
    }
    auto enclave_destructor =
        finally([&enclave] { oe_terminate_enclave(enclave); });

    size_t report_size = 0;
    uint8_t* report;
    result = oe_get_report_v2(enclave, 0, NULL, 0, &report, &report_size);
    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "oe_get_report(): result=%u (%s)\n",
            result,
            oe_result_str(result));
        throw EOTHER;
    }
    auto report_destructor = finally([&report] { oe_free_report(report); });

    {
        std::ofstream report_file(output_path);
        if (!report_file)
        {
            throw EOTHER;
        }
        report_file << std::string((char*)report, report_size);
    }
}

std::vector<uint8_t> get_file_contents(const std::string& filename)
{
    std::ifstream in(filename);
    if (!in)
    {
        throw EOTHER;
    }

    std::vector<uint8_t> contents;
    in.seekg(0, std::ios::end);
    contents.resize((size_t)in.tellg());
    in.seekg(0, std::ios::beg);
    in.read((char*)&contents.front(), contents.size());
    in.close();
    return contents;
}

oe_report_t append_report(const std::string& filename)
{
    std::vector<uint8_t> report = get_file_contents(filename);

    oe_report_t parsed_report;
    oe_result_t result =
        oe_parse_report(&report.front(), report.size(), &parsed_report);
    if (result != OE_OK)
    {
        throw EOTHER;
    }

    return parsed_report;
}

void iterate_over_pem_files(
    const std::string& source_directory,
    std::function<void(const std::string&)> action)
{
    const char* filename;

#ifdef WIN32
    HANDLE handle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA file_data;

    const std::string source_mask = source_directory + PEM_FILES;

    handle = FindFirstFile(source_mask.c_str(), &file_data);
    if (handle == INVALID_HANDLE_VALUE)
    {
        throw EOTHER;
    }
    auto handle_destructor = finally([&handle] { FindClose(handle); });

    do
    {
        filename = file_data.cFileName;

        action(filename);
    } while (FindNextFile(handle, &file_data));
#endif
#ifdef LINUX
    DIR* d = NULL;
    struct dirent* dir = NULL;

    d = opendir(source_directory.c_str());
    if (d == NULL)
    {
        throw EOTHER;
    }
    auto d_destructor([&d] { closedir(d); });

    while ((dir = readdir(d)) != NULL)
    {
        if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0)
        {
            continue;
        }
        filename = dir->d_name;

        action(filename);
    }
#endif
}

std::vector<oe_report_t> extract_reports(const std::string& source_directory)
{
    std::vector<oe_report_t> reports;

    auto action = [&reports, &source_directory](const std::string& filename) {
        const std::string fullpath = source_directory + "\\" + filename;
        oe_report_t new_report = append_report(fullpath);

        reports.push_back(new_report);
    };

    iterate_over_pem_files(source_directory, action);

    return reports;
}

void compose_policy(
    const std::string& source_directory,
    const std::string& output_path)
{
    std::vector<oe_report_t> reports;
    auto reports_destructor = finally([&reports] {
        for (size_t i = 0; i < reports.size(); i++)
        {
            oe_free_parsed_report(&reports[i]);
        }
    });

    reports = extract_reports(source_directory);

    generate_policy_json(reports, output_path);
}

bool str_i_eq(const std::string& str1, const std::string& str2)
{
    return std::equal(
        str1.begin(), str1.end(), str2.begin(), str2.end(), [](char a, char b) {
            return toupper(a) == toupper(b);
        });
}

int main(int argc, const char* argv[])
{
    if (argc < 2)
    {
        usage(argc, argv);
        return -1;
    }

    try
    {
        if (argc == 3 && str_i_eq(COMMAND_HARVEST, argv[1]))
        {
            harvest_report(argv[2]);
        }
        else if (argc == 4 && str_i_eq(COMMAND_COMPOSE, argv[1]))
        {
            compose_policy(argv[2], argv[3]);
        }
        else
        {
            usage(argc, argv);
            throw EOTHER;
        }
    }
    catch (...)
    {
        printf("Failed\n");
        return -2;
    }

    return 0;
}
