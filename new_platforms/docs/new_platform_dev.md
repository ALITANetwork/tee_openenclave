Developing your own enclave using CMake
=============

In this guide, you will learn how to create new applications that take advantage
of Trusted Execution Environments (TEEs) using the Open Enclave SDK.

There are two ways to develop host apps and enclaves using the Open Enclave SDK.

The first way is to use CMake as the build system and include the SDK in source
form as a sub-project. You can then edit your host apps and enclaves using the
text editor of your choice regardless of operating system. You can write host
apps for both Windows and Linux and enclaves for both Intel SGX and ARM
TrustZone, then easily build them in a cross-platform manner via CMake. If you
use an IDE that has CMake support, you can also build your code directly from
it. For example, Visual Studio 2017 supports CMake projects and there are
extensions for Visual Studio Code.

The second way is to use a Visual Studio extension that pulls in the Open
Enclave SDK in binary form via a NuGet package. This allows you to write host
apps for Windows and enclaves for both Intel SGX and ARM TrustZone using Visual
Studio and its familiar solution and projects paradigm. See [Developing your own
enclave using Visual Studio](visualstudio_dev.md) for details. While there is
nothing preventing a host app written in this way from running on Linux, the
Visual Studio extension only supports building it for Windows.

This guide shows you how to work using the first way: using CMake as the build
system and including the Open Enclave SDK as a sub-project.

# Introduction

Any application that uses the Open Enclave SDK is composed of two parts: the
host app and the enclave.

The interface between the host app and the enclave is defined using the [Enclave
Definition
Language](https://software.intel.com/en-us/sgx-sdk-dev-reference-enclave-definition-language-file-syntax),
or EDL. EDL files describe how a host app calls into an enclave to request a
secure service (i.e., an Enclave CALL, or ECALL), and how an enclave calls into
its host app to request an insecure service (i.e., an Out CALL, or OCALL). The
same EDL file is used to define the interface between the host app and the
enclave regardless of whether the enclave is an Intel SGX enclave or OP-TEE
trusted application (TA). An EDL file may include other EDL files and is
processed using the `oeedger8r` tool. This tool generates four files: a source
and a header file to be included by the host app, and a source and a header file
to be included by the enclave. The autogenerated files contain code to aid in
the marshalling of function calls and data across the host/enclave boundary such
that ECALLs and OCALLs appear as normal function calls to the developer. The
underlying platform- and TEE-specific behaviors are abstracted away.

# Quick Start

This quick start shows you how to quickly create your own host app and enclave.

## On Windows

Begin with an empty directory and do:

```
mkdir 3rdparty

git init

git submodule add -b feature.new_platforms https://github.com/Microsoft/openenclave 3rdparty/openenclave
git submodule update --init --recursive

echo build >> .gitignore

xcopy /s 3rdparty\openenclave\new_platforms\samples\helloworld .
copy 3rdparty\openenclave\new_platforms\CMakeSettings.json .
```

Open `enc/CMakeLists.txt` and change the name and UUID of the enclave. Then,
open `enc/optee/linux_gcc.mak` and `enc/optee/user_ta_header_defines.h` and
replicate the UUID change there. Additionally, open `host/CMakeLists.txt` and
change the name of host app target as well. Lastly, rename
`helloworld_enclave_private.pem` and `helloworld_enclave.config.xml` to match
the new name that you chose.

Open the top-level `CMakeLists.txt` file and insert at the top:

```
cmake_minimum_required(VERSION 3.12 FATAL_ERROR)

project("My Project" VERSION 0.1 LANGUAGES C)

set(OE_PATH ${PROJECT_SOURCE_DIR}/3rdparty/openenclave)

list(APPEND CMAKE_MODULE_PATH ${OE_PATH}/new_platforms/cmake)

add_subdirectory(${OE_PATH}/new_platforms EXCLUDE_FROM_ALL)
```

Launch Visual Studio 2017 and use File -> Open -> CMake... to open the file you
just edited. Visual Studio's CMake integration allows you to work with your code
in a fashion similar to using projects and solutions.

The build output is located, say for x86-SGX-Debug, under:

```
build\x86-SGX-Debug\out
```

The host app and enclave in turn are located under:

```
build\x86-SGX-Debug\out\bin\Debug
```

## On Linux

Begin with an empty directory and do:

```
mkdir 3rdparty

git init

git submodule add -b feature.new_platforms https://github.com/Microsoft/openenclave 3rdparty/openenclave
git submodule update --init --recursive

sudo apt update && sudo apt install -y          \
    build-essential cmake gcc-arm-linux-gnueabi \
    gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

cp -r 3rdparty/openenclave/new_platforms/samples/helloworld/* .

echo build >> .gitignore
echo toolchains >> .gitignore

mkdir build
mkdir build/arm
mkdir build/aarch64

mkdir toolchains
mkdir toolchains/arm
mkdir toolchains/aarch64

pushd toolchains

wget https://releases.linaro.org/components/toolchain/binaries/6.2-2016.11/arm-linux-gnueabihf/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf.tar.xz
wget https://releases.linaro.org/components/toolchain/binaries/6.2-2016.11/aarch64-linux-gnu/gcc-linaro-6.2.1-2016.11-x86_64_aarch64-linux-gnu.tar.xz

pushd arm
tar --strip-components=1 -xvf ../gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf.tar.xz
popd

pushd aarch64
tar --strip-components=1 -xvf ../gcc-linaro-6.2.1-2016.11-x86_64_aarch64-linux-gnu.tar.xz
popd

popd

pushd build/arm
ln -s ../../toolchains toolchains
popd

pushd build/aarch64
ln -s ../../toolchains toolchains
popd
```

Open `enc/CMakeLists.txt` and change the name and UUID of the enclave. Then,
open `enc/optee/linux_gcc.mak` and `enc/optee/user_ta_header_defines.h` and
replicate the UUID change there. Additionally, open `host/CMakeLists.txt` and
change the name of host app target as well. Lastly, rename
`helloworld_enclave_private.pem` and `helloworld_enclave.config.xml` to match
the new name that you chose.

Open the top-level `CMakeLists.txt` file and insert at the top:

```
cmake_minimum_required(VERSION 3.12 FATAL_ERROR)

project("My Project" VERSION 0.1 LANGUAGES C)

set(OE_PATH ${PROJECT_SOURCE_DIR}/3rdparty/openenclave)

list(APPEND CMAKE_MODULE_PATH ${OE_PATH}/new_platforms/cmake)

add_subdirectory(${OE_PATH}/new_platforms EXCLUDE_FROM_ALL)
```

On Linux for OP-TEE, you first need a TA Dev Kit. If you are working on a
specific board, you will need the TA Dev Kit that was produced as part of the
build of OP-TEE that is flashed on it. See the documentation for the
[Grapeboard](grapeboard.md) or [Linux Development](linux_arm_dev.md). Both of
these guides build OP-TEE as part of their instructions. If you are using a
board someone else flashed, ask them to give you the TA Dev Kit that goes with
the firmware.

For ARMv7:

```
pushd build/arm

cmake -DOE_TEE=TZ                                                                              \
      -DCMAKE_TOOLCHAIN_FILE=../../3rdparty/openenclave/new_platforms/cmake/linux-arm-v6.cmake \
      -DTA_DEV_KIT_DIR=path/to/optee_os/out/arm/export-ta_arm32                                \
      ../..
cmake --build . -- -j

popd
```

And for ARMv8:

```
pushd build/aarch64

cmake -DOE_TEE=TZ                                                                                  \
      -DCMAKE_TOOLCHAIN_FILE=../../3rdparty/openenclave/new_platforms/cmake/linux-aarch64-v6.cmake \
      -DTA_DEV_KIT_DIR=path/to/optee_os/out/arm/export-ta_arm64                                    \
      ../..
cmake --build . -- -j

popd
```

The build output is located, say for aarch64, under:

```
build/aarch64/out
```

The host app and enclave in turn are located under:

```
build/aarch64/out/bin
```

# Using the SDK

The Open Enclave SDK uses [CMake](https://cmake.org) as its build system for
cross-platform build support. The SDK exposes three CMake functions that enable
you to create your own cross-platform host app and enclave and are described in
this guide.

## Directory Structure

The following is a sample directory structure for an Open Enclave project:

```
my_project
  | 3rdparty
    | openenclave [remote]
      | ...
      | new_platforms
        | ...
        | CMakeLists.txt
  | enc
    | optee
      | linux_gcc.mak
      | sub.mak
      | user_ta_header_defines.h
      | uuids.reg
    | enc.c
    | myproject_enclave_private.pem
    | myproject_enclave.config.xml
    | CMakeLists.txt
  | host
    | main.c
    | CMakeLists.txt
  | interface.edl
  | CMakeLists.txt
```

The `3rdparty` directory collects external components to your project, including
the Open Enclave SDK. If you use Git for source control in your project, you can
use Git submodules to pull the Open Enclave SDK into the `3rdparty` directory.

The top-level `CMakeLists.txt` file sets up the CMake basics for your project,
imports the Open Enclave SDK from the 3rdparty directory, and instructs CMake to
recurse into the `enc` and `host` subdirectories. It looks like this:

```
cmake_minimum_required(VERSION 3.12 FATAL_ERROR)

project("My Project" VERSION 0.1 LANGUAGES C CXX)

set(OE_PATH ${PROJECT_SOURCE_DIR}/3rdparty/openenclave)

list(APPEND CMAKE_MODULE_PATH ${OE_PATH}/new_platforms/cmake)

add_subdirectory(3rdparty/openenclave/new_platforms)

add_subdirectory(enc)
add_subdirectory(host)
```

The `interface.edl` file describes the interface via which the host app and TA
communicate with one another. This EDL file contains only functionality that is
specific to your project. However, it references other EDL files provided by the
Open Enclave SDK. These referenced EDL files specify the interface through which
the trusted components of the SDK, which are linked into your enclave, and the
corresponding untrusted components of the SDK, which are linked into your host
app, talk with each other. The `oeedger8r` tool processes this file and
generates code that may be called by either the trusted or the untrusted side to
transparently communicate with the other side.

The `enc` directory holds the source code for your enclave, in this case a
single `enc.c` file. Under the `optee` folder there are files that are used by
the build process for OP-TEE. Currently, OP-TEE requires building TAs with GNU
Make and does not support CMake. The `sub.mk` file specifies the list of sources
a second time as well as per-file compiler flags, where necessary. Similarly,
the `linux_gcc.mak` file also contains a copy of the UUID value. The
`user_ta_header_defines.h` header file contains configuration values required by
OP-TEE, including the UUID as well in a C-structure format. The `uuids.reg`
registry file contains registry keys and values to register an OP-TEE TA with
the Windows Trusted Runtime via its UUID.

The file `myproject_enclave_private.pem` holds the private key in PEM format
with which to sign the enclave when the target TEE is Intel SGX. The file
`myproject_enclave_config.xml` contains configuration values required by Intel
SGX such as the max stack and heap sizes.

Lastly, there is a `CMakeLists.txt` file that describes to CMake how to build
the enclave.

The `host` directory holds the code for your host app, in this case a single
`main.c` file. This file contains OS- and TEE-agnostic host code that loads the
TA. Note that the code that you write for your host app need not know how to
launch an enclave under Intel SGX or a TA under OP-TEE nor how to do so under
both Windows and Linux. The Open Enclave SDK deals with these details on your
behalf. The `host` directory also has a `CMakeLists.txt` file that instructs
CMake how to build the host app executable.

In general then, there is an EDL file that both the trusted and untrusted
components consume that specifies how the pair communicate across the trust
boundary. The EDL file only contains functions that are specific to your use
case. The trusted component need only be written once and targets the Open
Enclave SDK's API. This way it can be seamlessly compiled as an Intel SGX
enclave and as an OP-TEE TA. Similarly, the host programs also need only be
written once and, assuming you do not make use of OS-specific functionality,
they too can be compiled into Windows and Linux programs that can seamlessly
launch and operate Intel SGX enclaves and OP-TEE TAs.

## Building the Enclave

The `CMakeLists.txt` file under `enc` looks like this:

```
include(oeedl_file)
include(add_enclave)

oeedl_file(../interface.edl enclave GEN C_GEN H_GEN ${OE_PATH}/include)

add_enclave(
    TARGET myproject_enc
    UUID c5c9f16c-1981-11e9-ab14-d663bd873d93
    SOURCES
        enc.c
        ${GEN}
    C_GEN ${C_GEN})
```

The first two lines include the contents of two external CMake files provided by
the OpenEnclave SDK. These files make available the `oeedl_file` and
`add_enclave` functions, respectively.

The third line invokes `oeedl_file`, specifying the path to your project's EDL
file and signals that `oeedger8r` should generate the set of files to include in
the enclave. After the call, the values `${GEN}`, `${C_GEN}` and `${H_GEN}`
contain the absolute paths to source and header files, the absolute path to the
source file, and the absolute path to the header file, respectively. The last
parameter indicates that `oeedger8r` should look for additional EDL files in the
`include` directory of the Open Enclave SDK, which `interface.edl` imports.

The fourth line invokes `add_enclave`. This function creates a library target
named `myproject_enc` if the project is configured to use Intel SGX enclaves or
`c5c9f16c-1981-11e9-ab14-d663bd873d93` if the project is configured to use
OP-TEE TAs (usage of a UUID is a requirement of OP-TEE). The function takes a
list of source files, including both the source and header files generated by
the call to `oeedl_file` as well as the path to the generated source file (also
required by OP-TEE). `add_enclave` configures the target with the required
include paths, and compiler and linker flags.

When building for OP-TEE, the `add_enclave` function invokes the underlying
`linux_gcc.mak` Makefile against the TA Dev Kit that you specify at
configure-time.

## Building the Host

The `CMakeLists.txt` file under `host` looks like this:

```
include(oeedl_file)
include(add_host)

oeedl_file(../helloworld.edl host GEN C_GEN H_GEN ${OE_PATH}/include)

add_host(
    TARGET myproject_host
    SOURCES host.c ${GEN})
```

The first line is the same as before, and the second imports the `add_host`
function, which is analogous to `add_enclave`, but for host apps instead.

The third line invokes `oeedl_file` and it behaves in the same way as before.
Note that the second parameter is now `host` instead of `enclave`. This
indicates to `oeedger8r` to generate the source and header file pair for
inclusion in a host app.

The fourth line invokes `add_host`. This function creates a target named
`myproject_host` and configures it with the required include paths, and compiler
and linker flags.

# Understanding the SDK

## Generating Calls between Enclaves and Host Apps

To use this SDK, you must define your own EDL file that defines any APIs you
want to use, and use `oeedger8r` to generate code from it. The same generated
code will work equally with both SGX and OP-TEE, as long as the enclave and the
host app both use the right include paths and libs, and the following additional
code constraint is met:

OP-TEE only allows one thread per TA to be in an ECALL (i.e., a call into a TA
from a host app). Even if it has an OCALL (i.e., an out-call back into the host
app) in progress, the ECALL must complete before another ECALL can enter the TA.
SGX, on the other hand, would allow a second ECALL to enter. So, if you want
them to function identically, host apps can pass the
`OE_ENCLAVE_FLAG_SERIALIZE_ECALLS` flag when creating an enclave to
automatically get the OP-TEE like behavior for both SGX and OP-TEE.

## Include paths, preprocessor defines, and libraries

This section is informational only, CMake takes care of configuring include
paths, processor defines, compiler flags, and linker flags.

### SGX Enclave

The SGX enclave should link with `oeenclave.lib` and have the following
additional include paths:

* `new_platforms\include\sgx\enclave`
* `new_platforms\include`

To use stdio APIs, the SGX Enclave DLL should link with `oestdio_enc.lib`. See
the helloworld sample for an example.

To use socket APIs, the SGX Enclave DLL should link with `oesocket_enc.lib`. See
the sockets sample for an example.

### SGX Host App

The host app should link with `oehost.lib` and have the following additional
include path:

* `new_platforms\include`

To allow the SGX enclave to use stdio APIs, the host app should link with
`oestdio_host.lib`. See the helloworld sample for an example.

To allow the SGX enclave to use socket APIs, the host app should link with
`oesocket_host.lib`. See the sockets sample for an example.

### OP-TEE TA

The OP-TEE TA should link with `liboeenclave` and have the following additional
include paths, in this order (the order is important because files in a deeper
directory override files at higher levels with the same filename):

* `new_platforms/include/optee/enclave`
* `new_platforms/include/optee`
* `new_platforms/include`

To use stdio APIs, the OP-TEE TA should link with `liboestdio_enc`. See the
helloworld sample for an example.

To use socket APIs, the OP-TEE TA should link with `liboesocket_enc`. See the
sockets sample for an example.

### OP-TEE Host App

The host app should link with `oehost.lib` and have the following additional
include paths, in any order:

* `new_platforms\include`
* `new_platforms\include\optee`
* `new_platforms\include\optee\host`

To allow the OP-TEE TA to use stdio APIs, the host app should link with
`oestdio_host.lib`. See the helloworld sample for an example.

To allow the OP-TEE TA to use socket APIs, the host app should link with
`oesocket_host.lib`. See the sockets sample for an example.

## Open Enclave APIs

This SDK implements the Open Enclave APIs covered in [API
docs](https://ms-iot.github.io/openenclave/api/files.html).

This SDK also provides support for a number of APIs that are not available in
SGX and/or OP-TEE. For APIs that would normally be in some standard C header
(e.g., "stdio.h"), the convention is that instead of including `*token*.h`, one
would include (instead or in addition to the one provided by SGX or OP-TEE if
any), `tcps_*token*_t.h` for defines common to both SGX and OP-TEE, or
`tcps_*token*_optee_t.h` for defines unique to OP-TEE, since the Intel SGX SDK
already provides more than OP-TEE provides and such files provide the equivalent
for OP-TEE.  For example, the following such headers exist:

* `tcps_stdlib_t.h`
* `tcps_string_t.h`
* `tcps_time_t.h`

Additional OP-TEE only headers that provide support already present in SGX
include:

* `tcps_ctype_optee_t.h`
* `tcps_string_optee_t.h`

If none of the above are needed, trusted code might need to `#include
<openenclave/enclave.h>` (as well as the `*_t.h` file generated from your
application's EDL file) to get basic definitions, but it should be pulled in
automatically if any of the above are included.

Untrusted code might need to `#include <openenclave/host.h>` (as well as the
`*_u.h` file generated from your application's EDL file) to get basic
definitions.

## Dependencies

The trusted component depends on the following Open Enclave-provided libraries:

* `oeenclave`: Provides core Open Enclave functionality;
* `oesocket_enc`: Provides sockets functionality inside the TA:
    * Linking is necessary only if you use sockets;
    * This library marshals socket calls out to the host app.
* `oestdio_enc`: Provides standard I/O functionality inside the TA:
    * Linking is necessary only if you use standard I/O;
    * This library marshals standard I/O calls out to the host app.

**Note**: When using sockets or I/O APIs, or any other trusted-to-untrusted
call, the data that you send into these APIs and out to the host app is not
automatically protected.

The untrusted component depends on the following Open Enclave-provided
libraries:

* `oehost`: Provides core Open Enclave functionality;
* `oesocket_host`: Provides the implementation of the socket calls that the
  trusted component makes:
    * Linking is necessary only if you use sockets inside the trusted component.
* `oestdio_host`: Provides the implementation of the standard I/O calls that the
  trusted component makes:
    * Linking is necessary only if you use standard I/O inside the trusted
      component.

Notice how these libraries come in pairs. The libraries provide Open
Enclave-provided APIs inside the trusted component. When you call these APIs,
they in turn invoke code generated by the `oeedger8r` tool as specified by the
SDK's EDL files, included by yours. This code marshals the calls across the
trust boundary which are captured by functions implemented in the corresponding
libraries in the host app. The same is true the other way around.

# CMake Functions Reference

## oeedl_file

Wraps the processing of an EDL file.

### Signature

```
oeedl_file(
    <edl_file>
    <type>
    <out_files_var>
    <out_c_files_var>
    <out_h_files_var>
    [--edl-search-dir edl_search_paths])
```

### Description

Processes an EDL file via the `oeedger8r` tool. The function generates a source
and header file pair for inclusion in the host app if the `type` parameter is
`host` and a source and header file pair for inclusion in the enclave if it is
`enclave`. The `out_files_var` parameter specifies the name of the variable in
the caller's scope which shall contain a list of absolute paths to the source
and header files. The `out_c_files_var` parameter specifies the name of the
variable in the caller's scope which shall receive the absolute path to the
source file and the `out_h_files_var` parameter likewise for the absolute path
to the header file. The parameter names are plural in case the tool generates
more than one source and header file in the future. Specify `--edl-search-dir
path1 path2 ...` at the end to add `path1 path2 ...` to the list of paths for
the `oeedger8r` tool to look for included EDL files.

### Arguments

- `edl_file`: Path to the EDL file to process.
- `TYPE`: One of `host` or `enclave`, specifies whether to generate a source and
  a header file to be included by the host app or by the enclave, respectively.
- `out_files_var`: Name of the variable to receive the list of paths to the
  autogenerated files.
- `out_c_files_var`: Name of the variable to receive the path to the
  autogenerated source file (subset of `out_files_var`).
- `out_h_files_var`: Name of the variable to receive the path to the
  autogenerated header file (subset of `out_files_var`).
- `--edl-search-dir`: List of additional paths to search for included EDL files.

## add_enclave

Adds a CMake target to build an enclave and configures the target accordingly.

### Signature

```
add_enclave(
    <TARGET target>
    <UUID uuid>
    <SOURCES sources>
    <C_GEN c_gen>)
```

### Description

On Windows, wraps a call to `add_library` and configures the target with the
appropriate include paths, and compiler and linker flags. On Linux, wraps a call
to `add_custom_target` and invokes the underlying OP-TEE `linux_gcc.mak` with
the TA Dev Kit directory as specified to CMake during configuration. The name of
the enclave is `target` if the underlying TEE is Intel SGX or `uuid` when the
underlying TEE is ARM TrustZone via OP-TEE.

### Arguments

- `TARGET target`: Named parameter specifying the name of the enclave when the
  TEE is Intel SGX.
- `UUID uuid`: Named parameter specifying the UUID of the eclave when the TEE is
  ARM TrustZone via OP-TEE.
- `SOURCES sources`: Named parameter specifying the list of source files for the
  enclave.
- `C_GEN c_gen`: Named parameter specifying list of source files generated via a
  call to `oeedl_file` (i.e., the value of the variable named passed as
  `out_c_files_var`). This is necessary to compile an enclave for ARM TrustZone
  via OP-TEE.

## add_host

Adds a CMake target to build a host app and configures the target accordingly.

### Signature

```
add_host(
    <TARGET target>
    <SOURCES sources>)
```

### Description

Adds a CMake target with name `target` and source files `sources`, then
configures it with the required header include paths, compiler and linker flags,
and adds dependencies to the required Open Enclave libraries.

### Arguments

- `TARGET target`: Named parameter specifying the name of the host app.
- `SOURCES sources`: Named parameter specifying the list of sources for the
  enclave.
