(* Copyright (c) Microsoft Corporation. All rights reserved.
   Licensed under the MIT License. *)

(** This module is Open Enclave's plugin for Intel's Edger8r, allowing
    us to share the same Enclave Definition Language, but emit our
    SDK's bindings. *)

open Ast
open Plugin
open Printf
open Util

(** ----- Begin code borrowed and tweaked from {!CodeGen.ml}. ----- *)
let is_foreign_array (pt: Ast.parameter_type) =
  match pt with
    Ast.PTVal _ -> false
  | Ast.PTPtr(t, a) ->
    match t with
      Ast.Foreign _ -> a.Ast.pa_isary
    | _ -> false

(** Get the array declaration from a list of array dimensions. Empty
    [ns] indicates the corresponding declarator is a simple identifier.
    Element of value -1 means that user does not specify the dimension
    size. *)
let get_array_dims (ns: int list) =
  let get_dim n = if n = -1 then "[]" else sprintf "[%d]" n
  in
  if ns = [] then ""
  else List.fold_left (fun acc n -> acc ^ get_dim n) "" ns

let get_typed_declr_str (ty: Ast.atype) (declr: Ast.declarator) =
  let tystr = Ast.get_tystr  ty in
  let dmstr = get_array_dims declr.Ast.array_dims in
  sprintf "%s %s%s" tystr declr.Ast.identifier dmstr

(** Check whether given parameter [pt] is [const] specified. *)
let is_const_ptr (pt: Ast.parameter_type) =
  let aty = Ast.get_param_atype pt in
  match pt with
    Ast.PTVal _ -> false
  | Ast.PTPtr(_, pa) ->
    if not pa.Ast.pa_rdonly then false
    else
      match aty with
        Ast.Foreign _ -> false
      | _ -> true

(** Generate parameter [p] representation. *)
let gen_parm_str (p: Ast.pdecl) =
  let (pt, (declr : Ast.declarator)) = p in
  let aty = Ast.get_param_atype pt in
  let str = get_typed_declr_str aty declr in
  if is_const_ptr pt then "const " ^ str else str

let retval_declr = { Ast.identifier = "_retval"; Ast.array_dims = []; }
let get_ret_tystr (fd: Ast.func_decl) = Ast.get_tystr fd.Ast.rtype
let get_plist_str (fd: Ast.func_decl) =
  if fd.Ast.plist = [] then ""
  else List.fold_left (fun acc pd -> acc ^ ",\n        " ^ gen_parm_str pd)
      (gen_parm_str (List.hd fd.Ast.plist))
      (List.tl fd.Ast.plist)

(** [conv_array_to_ptr] is used to convert Array form into Pointer form.
    {[
      int array[10][20] => [count = 200] int* array
    ]}

    This function is called when generating proxy/bridge code and the
    marshalling structure. *)
let conv_array_to_ptr (pd: Ast.pdecl): Ast.pdecl =
  let (pt, declr) = pd in
  let get_count_attr ilist =
    (* XXX: assume the size of each dimension will be > 0. *)
    Ast.ANumber (List.fold_left (fun acc i -> acc*i) 1 ilist)
  in
  match pt with
    Ast.PTVal _ ->  (pt, declr)
  | Ast.PTPtr(aty, pa) ->
    if Ast.is_array declr then
      let tmp_declr = { declr with Ast.array_dims = [] } in
      let tmp_aty = Ast.Ptr aty in
      let tmp_cnt = get_count_attr declr.Ast.array_dims in
      let tmp_pa = { pa with Ast.pa_size = { Ast.empty_ptr_size with Ast.ps_count = Some tmp_cnt } }
      in (Ast.PTPtr(tmp_aty, tmp_pa), tmp_declr)
    else (pt, declr)

(** Note that, for a foreign array type [foo_array_t] we will generate
    [foo_array_t* ms_field;] in the marshalling data structure to keep
    the pass-by-address scheme as in the C programming language. *)
let mk_ms_member_decl (pt: Ast.parameter_type) (declr: Ast.declarator) (isecall: bool) =
  let aty = Ast.get_param_atype pt in
  let tystr =
    if is_foreign_array pt then
      sprintf "/* foreign array of type %s */ void" (Ast.get_tystr aty)
    else Ast.get_tystr aty
  in
  let ptr = if is_foreign_array pt then "* " else "" in
  let field = declr.Ast.identifier in
  (* String attribute is available for in/in-out both ecall and ocall.
     For ocall ,strlen is called in trusted proxy code, so no need to
     defense it. *)
  let need_str_len_var (pt: Ast.parameter_type) =
    match pt with
      Ast.PTVal _ -> false
    | Ast.PTPtr(_, pa) ->
      if pa.Ast.pa_isstr || pa.Ast.pa_iswstr then
        match pa.Ast.pa_direction with
          Ast.PtrInOut | Ast.PtrIn ->  if isecall then true else false
        | _ -> false
      else false
  in
  let str_len = if need_str_len_var pt then sprintf "\tsize_t %s_len;\n" field else ""
  in
  let dmstr = get_array_dims declr.Ast.array_dims in
  sprintf "\t%s%s %s%s;\n%s" tystr ptr field dmstr str_len

(** ----- End code borrowed and tweaked from {!CodeGen.ml} ----- *)

(** [open_file] opens [filename] in the directory [dir] and emits a
    comment noting the file is auto generated. *)
let open_file (filename:string) (dir:string) =
  let os = if dir = "." then
      open_out filename
    else
      open_out (dir ^ separator_str ^ filename) in
  fprintf os "/*\n";
  fprintf os " *  This file is auto generated by oeedger8r. DO NOT EDIT.\n";
  fprintf os " */\n";
  os

(** [oe_mk_ms_struct_name] appends our [struct] naming suffix. *)
let oe_mk_ms_struct_name (fname: string) = fname ^ "_args_t"

(** [oe_mk_struct_decl] constructs the string of a [struct] definition. *)
let oe_mk_struct_decl (fs: string) (name: string) =
  sprintf "typedef struct _%s {\n    oe_result_t _result;\n%s } %s;\n" name fs name

(** [oe_gen_marshal_struct_impl] generates a marshalling [struct]
    definition. *)
let oe_gen_marshal_struct_impl (fd: Ast.func_decl) (errno: string) (isecall: bool) =
  let member_list_str = errno ^
                        let new_param_list = List.map conv_array_to_ptr fd.Ast.plist in
                        List.fold_left (fun acc (pt, declr) ->
                            acc ^ mk_ms_member_decl pt declr isecall) "" new_param_list in
  let struct_name = oe_mk_ms_struct_name fd.Ast.fname in
  match fd.Ast.rtype with
    Ast.Void -> oe_mk_struct_decl member_list_str struct_name
  | _ -> let rv_str = mk_ms_member_decl (Ast.PTVal fd.Ast.rtype) retval_declr isecall
    in oe_mk_struct_decl (rv_str ^ member_list_str) struct_name

let oe_gen_ecall_marshal_struct (tf: Ast.trusted_func) =
  oe_gen_marshal_struct_impl tf.Ast.tf_fdecl "" true

let oe_gen_ocall_marshal_struct (uf: Ast.untrusted_func) =
  let errno_decl = if uf.Ast.uf_propagate_errno then "\tint _ocall_errno;\n" else "" in
  oe_gen_marshal_struct_impl uf.Ast.uf_fdecl errno_decl true

(** [oe_get_param_size] is the most complex function. For a parameter,
    get its size expression. *)
let oe_get_param_size (ptype, decl, argstruct) =
  (* Get the base type of the parameter, that is, recursively
     decompose the pointer. *)
  let atype =
    match Ast.get_param_atype ptype with
    | Ast.Ptr at -> at
    | _ -> Ast.get_param_atype ptype
  in
  let base_t = Ast.get_tystr atype in

  let type_expr =
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_isptr then
        sprintf "*(%s)0" base_t
      else base_t
    | _ -> base_t
  in

  (* Convert an attribute to string. *)
  let attr_value_to_string av =
    match av with
    | None -> ""
    | Some (Ast.ANumber n) -> string_of_int n
    | Some (Ast.AString s) -> sprintf "%s%s" argstruct s  (* another parameter name *)
  in
  let pa_size_to_string pa =
    let c = attr_value_to_string pa.Ast.ps_count in
    if c <> "" then sprintf "(%s * sizeof(%s))" c type_expr
    else attr_value_to_string pa.Ast.ps_size
  in
  let decl_size_to_string (ptype:Ast.parameter_type) (d:Ast.declarator) =
    let dims = List.map  (fun i-> "[" ^ (string_of_int i) ^ "]") d.Ast.array_dims in
    let dims_expr = String.concat "" dims in
    sprintf "sizeof(%s%s)" type_expr dims_expr
  in
  match ptype with
    Ast.PTPtr (atype, ptr_attr) ->
    let pa_size = pa_size_to_string ptr_attr.Ast.pa_size in
    (* Compute declared size *)
    let decl_size = decl_size_to_string ptype decl in
    if ptr_attr.Ast.pa_isstr then
      argstruct ^ decl.Ast.identifier ^ "_len * sizeof(char)"
    else if ptr_attr.Ast.pa_iswstr then
      argstruct ^ decl.Ast.identifier ^ "_len * sizeof(wchar_t)"
    else
      (* Prefer size attribute over decl size *)
    if pa_size="" then decl_size else pa_size
  | _ -> ""


(** Generate the prototype for a given function. Optionally add an
    [oe_enclave_t*] first parameter. *)
let oe_gen_prototype (fd: Ast.func_decl) =
  let params_str =
    if List.length fd.Ast.plist = 0 then
      "void"
    else get_plist_str fd in
  sprintf "%s %s(%s)" (get_ret_tystr fd) fd.Ast.fname params_str

let oe_gen_wrapper_prototype (fd: Ast.func_decl) (is_ecall:bool) =
  let plist_str = get_plist_str fd in
  let retval_str =
    if fd.Ast.rtype = Ast.Void then ""
    else sprintf "%s* _retval" (get_ret_tystr fd) in
  let args =
    if is_ecall then
      ["oe_enclave_t* enclave"; retval_str; plist_str]
    else
      [retval_str; plist_str] in
  let args = List.filter (fun s-> s <> "") args
  in
  sprintf "oe_result_t %s(\n        %s)" fd.Ast.fname (String.concat ",\n        " args)

let emit_struct_or_union (os:out_channel) (s:Ast.struct_def) (union:bool) =
  fprintf os "typedef %s %s {\n" (if union then "union" else "struct") s.Ast.sname;
  List.iter (fun (atype, decl) ->
      let dims = List.map (fun d-> sprintf "[%d]" d) decl.Ast.array_dims in
      let dims_str = String.concat "" dims in
      fprintf os "    %s %s%s;\n" (Ast.get_tystr atype) decl.Ast.identifier dims_str
    ) s.Ast.mlist;
  fprintf os "} %s;\n\n" s.Ast.sname

let emit_enum (os:out_channel) (e:Ast.enum_def) =
  let n = List.length e.Ast.enbody in
  fprintf os "typedef enum %s {\n" e.Ast.enname;
  List.iteri (fun idx (name, value) ->
      fprintf os "    %s%s" name
        (match value with
         | Ast.EnumVal (Ast.AString s) -> " = " ^ s
         | Ast.EnumVal (Ast.ANumber n) -> " = " ^ (string_of_int n)
         | Ast.EnumValNone -> "");
      if idx != (n-1) then fprintf os ",\n"
    ) e.Ast.enbody;
  fprintf os "} %s;\n\n" e.Ast.enname

(** Emit [struct], [union], or [enum]. *)
let emit_composite_type (os:out_channel) = function
  | Ast.StructDef s -> emit_struct_or_union os s false
  | Ast.UnionDef u -> emit_struct_or_union os u true
  | Ast.EnumDef e -> emit_enum os e

let get_function_id (f:Ast.func_decl) =
  sprintf "fcn_id_%s" f.fname

(** Emit all trusted and untrusted function IDs in enclave [ec]. *)
let emit_function_ids (os:out_channel) (ec: enclave_content) =
  fprintf os "\n/* trusted function ids */\n";
  fprintf os "enum {\n";
  List.iteri (fun idx f ->
      fprintf os "    %s = %d,\n" (get_function_id f.Ast.tf_fdecl) idx
    ) ec.tfunc_decls;
  fprintf os "    fcn_id_trusted_call_id_max = OE_ENUM_MAX\n";
  fprintf os "};\n\n";
  fprintf os "\n/* untrusted function ids */\n";
  fprintf os "enum {\n";
  List.iteri (fun idx f ->
      fprintf os "    %s = %d,\n" (get_function_id f.Ast.uf_fdecl) idx
    ) ec.ufunc_decls;
  fprintf os "    fcn_id_untrusted_call_max = OE_ENUM_MAX\n";
  fprintf os "};\n\n"

(** Generate [args.h] which contains [struct]s for ecalls and ocalls *)
let oe_gen_args_header (ec: enclave_content) (dir:string)=
  let structs = List.append
      (* For each ecall, generate its marshalling struct. *)
      (List.map oe_gen_ecall_marshal_struct ec.tfunc_decls)
      (* For each ocall, generate its marshalling struct. *)
      (List.map oe_gen_ocall_marshal_struct ec.ufunc_decls)
  in
  let with_errno = List.exists (fun uf -> uf.Ast.uf_propagate_errno) ec.ufunc_decls in
  let header_fname = sprintf "%s_args.h" ec.file_shortnm in
  let guard_macro = sprintf "%s_ARGS_H" (String.uppercase ec.enclave_name) in
  let os = open_file header_fname dir in
  fprintf os "#ifndef %s\n" guard_macro;
  fprintf os "#define %s\n\n" guard_macro;
  fprintf os "#include <stdint.h>\n";
  fprintf os "#include <stdlib.h> /* for wchar_t */\n\n";
  if with_errno then fprintf os "#include <errno.h>\n";
  fprintf os "#include <openenclave/bits/result.h>\n\n";
  List.iter (fun inc -> fprintf os "#include \"%s\"\n" inc) ec.include_list;
  if ec.include_list <> [] then fprintf os "\n";
  if ec.comp_defs <> [] then fprintf os "/* User types specified in edl */\n";
  List.iter (emit_composite_type os) ec.comp_defs;
  if ec.comp_defs <> [] then fprintf os "\n";
  fprintf os "%s" (String.concat "\n" structs);
  emit_function_ids os ec;
  fprintf os "\n#endif // %s\n" guard_macro;
  close_out os

(** Generate a cast expression for a pointer argument. Pointer
    arguments need to be cast to their root type, since the marshalling
    struct has the root pointer. For example:
    {[
      int a[10][20]
    ]}
    needs to be cast to [int *].

    NOTE: Foreign arrays are marshalled as [void *], but foreign pointers
    are marshalled as-is. *)
let get_cast_to_mem_expr (ptype, decl)=
  match ptype with
  | Ast.PTVal _ -> ""
  | Ast.PTPtr (t, _) ->
    if Ast.is_array decl then
      sprintf "(%s*) " (get_tystr t)
    else if is_foreign_array ptype then
      sprintf "/* foreign array of type %s */ (void*) " (get_tystr t)
    else
      sprintf "(%s) " (get_tystr t)

(** This function is nearly identical to the above, but does not
    surround the expression with the final set of parentheses, which is
    necessary for passing it to C macros. *)
let get_cast_to_mem_type (ptype, decl)=
  match ptype with
  | Ast.PTVal _ -> ""
  | Ast.PTPtr (t, _) ->
    if Ast.is_array decl then
      (get_tystr t) ^ "*"
    else if is_foreign_array ptype then
      sprintf "/* foreign array of type %s */ void* " (get_tystr t)
    else
      get_tystr t

(** Prepare [input_buffer]. *)
let oe_prepare_input_buffer (os:out_channel) (fd:Ast.func_decl) (alloc_func:string) =
  fprintf os "    /* Compute input buffer size. Include in and in-out parameters. */\n";
  fprintf os "    OE_ADD_SIZE(_input_buffer_size, sizeof(%s_args_t));\n" fd.Ast.fname;
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_chkptr then
          match ptr_attr.Ast.pa_direction with
          | Ast.PtrIn | Ast.PtrInOut ->
            let size = oe_get_param_size (ptype, decl, "_args.") in
            fprintf os "    if (%s) OE_ADD_SIZE(_input_buffer_size, %s);\n" decl.Ast.identifier size
          | _ -> ()
        else ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n";
  fprintf os "    /* Compute output buffer size. Include out and in-out parameters. */\n";
  fprintf os "    OE_ADD_SIZE(_output_buffer_size, sizeof(%s_args_t));\n" fd.Ast.fname;
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_chkptr then
          match ptr_attr.Ast.pa_direction with
          | Ast.PtrOut | Ast.PtrInOut ->
            let size = oe_get_param_size (ptype, decl, "_args.") in
            fprintf os "    if (%s) OE_ADD_SIZE(_output_buffer_size, %s);\n" decl.Ast.identifier size
          | _ -> ()
        else ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n";
  fprintf os "    /* Allocate marshalling buffer */\n";
  fprintf os "    _total_buffer_size = _input_buffer_size;\n";
  fprintf os "    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);\n\n";
  fprintf os "    _buffer = (uint8_t*) %s(_total_buffer_size);\n" alloc_func;
  fprintf os "    _input_buffer = _buffer;\n";
  fprintf os "    _output_buffer = _buffer + _input_buffer_size;\n";
  fprintf os "    if (_buffer == NULL) {\n";
  fprintf os "        _result = OE_OUT_OF_MEMORY;\n";
  fprintf os "        goto done;\n";
  fprintf os "    }\n\n";

  (* Serialize in and in-out parameters *)
  fprintf os "    /* Serialize buffer inputs (in and in-out parameters) */\n";
  fprintf os "    _pargs_in = (%s_args_t*)_input_buffer;\n" fd.Ast.fname;
  fprintf os "    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));\n\n";
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_chkptr then
          let size = oe_get_param_size (ptype, decl, "_args.") in
          let tystr = get_cast_to_mem_type (ptype, decl) in
          match ptr_attr.Ast.pa_direction with
          | Ast.PtrIn -> fprintf os "    OE_WRITE_IN_PARAM(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | Ast.PtrInOut -> fprintf os "    OE_WRITE_IN_OUT_PARAM(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | _ -> ()
        else ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n    /* Copy args structure (now filled) to input buffer */\n";
  fprintf os "    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));\n\n"

let oe_process_output_buffer (os:out_channel) (fd:Ast.func_decl) =
  (* Verify that the ecall succeeded *)
  fprintf os "    /* Set up output arg struct pointer */\n";
  fprintf os "    _pargs_out = (%s_args_t*)_output_buffer;\n" fd.Ast.fname;
  fprintf os "    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));\n\n";
  fprintf os "    /* Check if the call succeeded */\n";
  fprintf os "    if ((_result=_pargs_out->_result) != OE_OK)\n";
  fprintf os "        goto done;\n\n";
  fprintf os "    /* Currently exactly _output_buffer_size bytes must be written */\n";
  fprintf os "    if (_output_bytes_written != _output_buffer_size) {\n";
  fprintf os "        _result = OE_FAILURE;\n";
  fprintf os "        goto done;\n";
  fprintf os "    }\n\n";


  (* Unmarshal return value and ouput buffers *)
  fprintf os "    /* Unmarshal return value and out, in-out parameters */\n";
  (if fd.Ast.rtype <> Ast.Void then
     fprintf os "    *_retval = _pargs_out->_retval;\n");
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_chkptr then
           let size = oe_get_param_size (ptype, decl, "_args.") in
           match ptr_attr.Ast.pa_direction with
           | Ast.PtrOut ->
	      (* strings cannot be out parameters *)
	      fprintf os "    OE_READ_OUT_PARAM(%s, (size_t)(%s));\n" decl.Ast.identifier size
	   | Ast.PtrInOut ->
              (* Check that strings are null terminated.
                 Note output buffer has already been copied into the enclave.*)
              if ptr_attr.Ast.pa_isstr then
                  fprintf os "    OE_CHECK_NULL_TERMINATOR(_output_buffer + _output_buffer_offset, _args.%s_len);\n" decl.Ast.identifier
              else if ptr_attr.Ast.pa_iswstr then
                  fprintf os "    OE_CHECK_NULL_TERMINATOR_WIDE(_output_buffer + _output_buffer_offset, _args.%s_len);\n" decl.Ast.identifier
              else ();
              fprintf os "    OE_READ_IN_OUT_PARAM(%s, (size_t)(%s));\n" decl.Ast.identifier size
	   | _ -> ()
        else  ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n"

(** Generate a cast expression to a specific pointer type. For example,
    [int*] needs to be cast to
    {[
      *(int ( * )[5][6])
    ]}. *)
let get_cast_from_mem_expr (ptype, decl)=
  match ptype with
  | Ast.PTVal _ -> ""
  | Ast.PTPtr (t, attr) ->
    if Ast.is_array decl then
      sprintf "*(%s (*)%s) " (get_tystr t) (get_array_dims decl.Ast.array_dims)
    else if is_foreign_array ptype then
      sprintf "/* foreign array */ *(%s *) " (get_tystr t)
    else
    if attr.Ast.pa_rdonly then
      (* for ptrs, only constness is removed; add it back *)
      sprintf "(const %s) " (get_tystr t)
    else ""

let oe_copy_members_to_enclave (os:out_channel) (fd: Ast.func_decl) =
  let is_primitive ptype =
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) -> not ptr_attr.Ast.pa_chkptr
    | _ -> true
  in
  let gen_copy_member (ptype, decl) =
    if is_primitive ptype then
      fprintf os "    enc_args.%s = args.%s;\n"
        decl.Ast.identifier
        decl.Ast.identifier
  in
  fprintf os "    /* Copy primitive properties to enc_args */\n";
  List.iter gen_copy_member fd.Ast.plist;
  fprintf os "\n"

let oe_gen_allocate_buffers (os:out_channel) (fd: Ast.func_decl) =
  let gen_allocate_buffer (ptype, decl) =
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        let size = oe_get_param_size (ptype, decl, "args.") in
        let macro =
          match ptr_attr.Ast.pa_direction with
          | Ast.PtrOut -> "OE_CHECKED_ALLOCATE_OUTPUT"
          | _ -> "OE_CHECKED_COPY_INPUT"
        in
        fprintf os "    %s(enc_args.%s, args.%s, %s);\n"
          macro decl.Ast.identifier
          decl.Ast.identifier
          size
      else ()
    | _ -> () (* Non pointer arguments *)
  in
  fprintf os "    /* Copy checked buffers properties to enclave memory */\n";
  List.iter gen_allocate_buffer fd.Ast.plist;
  fprintf os "\n"

let oe_gen_free_buffers (os:out_channel) (fd: Ast.func_decl) =
  let gen_free_buffer (ptype, decl) =
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        (fprintf os "    if (enc_args.%s)\n" decl.Ast.identifier;
         fprintf os "        free (enc_args.%s);\n" decl.Ast.identifier)
      else ()
    | _ -> () (* Non pointer arguments *)
  in
  fprintf os "    /* Free enclave buffers */\n";
  List.iter gen_free_buffer fd.Ast.plist;
  fprintf os "\n"

let oe_gen_copy_outputs (os:out_channel) (fd: Ast.func_decl) =
  let gen_free_buffer (ptype, decl) =
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        match ptr_attr.Ast.pa_direction with
          Ast.PtrOut | Ast.PtrInOut ->
          fprintf os "    if (args.%s)\n" decl.Ast.identifier;
          fprintf os "        memcpy(args.%s, enc_args.%s, %s);\n"
            decl.Ast.identifier
            decl.Ast.identifier
            (oe_get_param_size (ptype, decl, "args."))
        | _ -> ()
      else ()
    | _ -> () (* Non pointer arguments *)
  in
  fprintf os "\n    /* Copy output buffers */\n";
  List.iter gen_free_buffer fd.Ast.plist;
  fprintf os "\n"

let oe_gen_call_function (os:out_channel) (fd: Ast.func_decl) =
  let params = List.map (fun (pt, decl) ->
      sprintf "%spargs_in->%s" (get_cast_from_mem_expr (pt, decl))decl.Ast.identifier) fd.Ast.plist
  in
  let params_str = "(\n        " ^ (String.concat ",\n        " params ) ^ ")" in
  let ret_str = match fd.Ast.rtype with
    | Ast.Void -> ""
    | _ -> "pargs_out->_retval = " in
  let call_str = ret_str ^ fd.Ast.fname ^ params_str in
  fprintf os "    /* Call user function */\n";
  fprintf os "    %s;\n" call_str

(** Generate ecall function. *)
let oe_gen_ecall_function (os:out_channel) (fd: Ast.func_decl) =
  fprintf os "void ecall_%s(\n" fd.Ast.fname;
  fprintf os "        uint8_t* input_buffer, size_t input_buffer_size,\n";
  fprintf os "        uint8_t* output_buffer, size_t output_buffer_size,\n";
  fprintf os "        size_t* output_bytes_written)\n";
  fprintf os "{\n";

  (* Variable declarations *)
  fprintf os "    oe_result_t _result = OE_FAILURE;\n\n";
  fprintf os "    /* Prepare parameters */\n";
  fprintf os "    %s_args_t* pargs_in = (%s_args_t*) input_buffer;\n" fd.Ast.fname fd.Ast.fname;
  fprintf os "    %s_args_t* pargs_out = (%s_args_t*) output_buffer;\n\n" fd.Ast.fname fd.Ast.fname;
  fprintf os "    size_t input_buffer_offset = 0;\n";
  fprintf os "    size_t output_buffer_offset = 0;\n";
  fprintf os "    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));\n";
  fprintf os "    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));\n\n";

  (* Buffer validation *)
  fprintf os "    /* Make sure input and output buffers lie within the enclave */\n";
  fprintf os "    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))\n";
  fprintf os "        goto done;\n\n";
  fprintf os "    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))\n";
  fprintf os "        goto done;\n\n";

  (* Prepare in and in-out parameters *)
  fprintf os "    /* Set in and in-out pointers */\n";
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_chkptr then
          let size = oe_get_param_size (ptype, decl, "pargs_in->") in
          let tystr = get_cast_to_mem_type (ptype, decl) in
          match ptr_attr.Ast.pa_direction with
          | Ast.PtrIn -> fprintf os "    OE_SET_IN_POINTER(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | Ast.PtrInOut -> fprintf os "    OE_SET_IN_OUT_POINTER(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | _ -> ()
        else ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n";

  (* Prepare out and in-out parameters. The in-out parameter is copied
     to output buffer. *)
  fprintf os "    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */\n";
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_chkptr then
          let size = oe_get_param_size (ptype, decl, "pargs_in->") in
          let tystr = get_cast_to_mem_type (ptype, decl) in
          match ptr_attr.Ast.pa_direction with
          | Ast.PtrOut -> fprintf os "    OE_SET_OUT_POINTER(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | Ast.PtrInOut -> fprintf os "    OE_COPY_AND_SET_IN_OUT_POINTER(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | _ -> ()
        else ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n";

  (* Check for null terminators in string parameters *)
  fprintf os "    /* Check that in/in-out strings are null terminated */\n";
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_isstr || ptr_attr.Ast.pa_iswstr then
          let check_string = "OE_CHECK_NULL_TERMINATOR" ^
                             (if ptr_attr.Ast.pa_iswstr then "_WIDE" else "") in
	  match ptr_attr.Ast.pa_direction with
          | Ast.PtrIn
          | Ast.PtrInOut -> fprintf os "    %s(pargs_in->%s, pargs_in->%s_len);\n" check_string decl.Ast.identifier decl.Ast.identifier
          | _ -> ()
        else ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n";

  (* Call the enclave function *)
  fprintf os "    /* lfence after checks */\n";
  fprintf os "    oe_lfence();\n\n";
  oe_gen_call_function os fd;

  (* Mark call as success *)
  fprintf os "\n    /* Success. */\n";
  fprintf os "    _result = OE_OK;\n";
  fprintf os "    *output_bytes_written = output_buffer_offset;\n\n";
  fprintf os "done:\n";

  (* oe_gen_free_buffers os fd; *)
  fprintf os "    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))\n";
  fprintf os "        pargs_out->_result = _result;\n";
  fprintf os "}\n\n"

let oe_gen_ecall_functions (os:out_channel) (ec: enclave_content)  =
  fprintf os "\n\n/****** ECALL function wrappers  *************/\n";
  List.iter
    (fun f -> oe_gen_ecall_function os f.Ast.tf_fdecl)
    ec.tfunc_decls

let oe_gen_ecall_table (os:out_channel) (ec: enclave_content)  =
  fprintf os "\n\n/****** ECALL function table  *************/\n";
  fprintf os "oe_ecall_func_t __oe_ecalls_table[] = {\n";
  List.iter
    (fun f -> fprintf os "    (oe_ecall_func_t) ecall_%s,\n" f.Ast.tf_fdecl.fname)
    ec.tfunc_decls;
  fprintf os "};\n\n";
  fprintf os "size_t __oe_ecalls_table_size = OE_COUNTOF(__oe_ecalls_table);\n\n"

let gen_fill_marshal_struct (os:out_channel) (fd:Ast.func_decl)  (args:string) =
  (* Generate assignment argument to corresponding field in args *)
  List.iter (fun (ptype, decl)->
      let varname = decl.Ast.identifier in
      fprintf os "    %s.%s = %s%s;\n" args varname (get_cast_to_mem_expr (ptype, decl)) varname;
      (* for string parameter fill the len field *)
      match ptype with
      | Ast.PTPtr(_, attr) ->
        if attr.Ast.pa_isstr then
          fprintf os "    %s.%s_len = (%s) ? (strlen(%s) + 1) : 0;\n" args varname varname varname
        else if attr.Ast.pa_iswstr then
          fprintf os "    %s.%s_len = (%s) ? (wcslen(%s) + 1) : 0;\n" args varname varname varname
      | _ ->()
    ) fd.Ast.plist;
  fprintf os "\n"

let oe_get_host_ecall_function (os:out_channel) (fd:Ast.func_decl) =
  fprintf os "%s" (oe_gen_wrapper_prototype fd true);
  fprintf os "\n";
  fprintf os "{\n";
  fprintf os "    oe_result_t _result = OE_FAILURE;\n\n";
  fprintf os "    /* Marshalling struct */\n";
  fprintf os "    %s_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;\n\n" fd.Ast.fname;
  fprintf os "    /* Marshalling buffer and sizes */\n";
  fprintf os "    size_t _input_buffer_size = 0;\n";
  fprintf os "    size_t _output_buffer_size = 0;\n";
  fprintf os "    size_t _total_buffer_size = 0;\n";
  fprintf os "    uint8_t* _buffer = NULL;\n";
  fprintf os "    uint8_t* _input_buffer = NULL;\n";
  fprintf os "    uint8_t* _output_buffer = NULL;\n";
  fprintf os "    size_t _input_buffer_offset = 0;\n";
  fprintf os "    size_t _output_buffer_offset = 0;\n";
  fprintf os "    size_t _output_bytes_written = 0;\n\n";
  fprintf os "    /* Fill marshalling struct */\n";
  fprintf os "    memset(&_args, 0, sizeof(_args));\n";
  gen_fill_marshal_struct os fd "_args";
  oe_prepare_input_buffer os fd "malloc";
  fprintf os "    /* Call enclave function */\n";
  fprintf os "    if((_result = oe_call_enclave_function(\n";
  fprintf os "                        enclave,\n";
  fprintf os "                        %s,\n" (get_function_id fd);
  fprintf os "                        _input_buffer, _input_buffer_size,\n";
  fprintf os "                        _output_buffer, _output_buffer_size,\n";
  fprintf os "                         &_output_bytes_written)) != OE_OK)\n";
  fprintf os "        goto done;\n\n";
  oe_process_output_buffer os fd;
  fprintf os "    _result = OE_OK;\n";
  fprintf os "done:\n";
  fprintf os "    if (_buffer)\n";
  fprintf os "        free(_buffer);\n";
  fprintf os "    return _result;\n";
  fprintf os "}\n\n"

let iter_ptr_params f params =
  List.iter (fun (ptype, decl)->
      match ptype with
      | Ast.PTPtr(_, attr) -> f (ptype, decl, attr)
      | _ -> ()
    ) params

(** Generate ocalls wrapper function. *)
let oe_gen_ocall_enclave_wrapper (os:out_channel) (uf:Ast.untrusted_func) =
  let propagate_errno = uf.Ast.uf_propagate_errno in
  let fd = uf.Ast.uf_fdecl in
  fprintf os "%s" (oe_gen_wrapper_prototype fd false);
  fprintf os "\n";
  fprintf os "{\n";
  fprintf os "    oe_result_t _result = OE_FAILURE;\n\n";
  fprintf os "    /* If the enclave is in crashing/crashed status, new OCALL should fail\n";
  fprintf os "       immediately. */\n";
  fprintf os "    if (oe_get_enclave_status() != OE_OK)\n";
  fprintf os "        return oe_get_enclave_status();\n\n";
  fprintf os "    /* Marshalling struct */\n";
  fprintf os "    %s_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;\n\n" fd.Ast.fname;
  fprintf os "    /* Marshalling buffer and sizes */\n";
  fprintf os "    size_t _input_buffer_size = 0;\n";
  fprintf os "    size_t _output_buffer_size = 0;\n";
  fprintf os "    size_t _total_buffer_size = 0;\n";
  fprintf os "    uint8_t* _buffer = NULL;\n";
  fprintf os "    uint8_t* _input_buffer = NULL;\n";
  fprintf os "    uint8_t* _output_buffer = NULL;\n";
  fprintf os "    size_t _input_buffer_offset = 0;\n";
  fprintf os "    size_t _output_buffer_offset = 0;\n";
  fprintf os "    size_t _output_bytes_written = 0;\n\n";
  fprintf os "    /* Fill marshalling struct */\n";
  fprintf os "    memset(&_args, 0, sizeof(_args));\n";
  gen_fill_marshal_struct os fd "_args";
  oe_prepare_input_buffer os fd "oe_allocate_ocall_buffer";
  fprintf os "    /* Call host function */\n";
  fprintf os "    if((_result = oe_call_host_function(\n";
  fprintf os "                        %s,\n" (get_function_id fd);
  fprintf os "                        _input_buffer, _input_buffer_size,\n";
  fprintf os "                        _output_buffer, _output_buffer_size,\n";
  fprintf os "                         &_output_bytes_written)) != OE_OK)\n";
  fprintf os "        goto done;\n\n";
  oe_process_output_buffer os fd;

  (* Propagate errno *)
  (if propagate_errno then
     begin
       fprintf os "    /* Propagate errno */\n";
       fprintf os "    errno = _pargs_out->_ocall_errno;\n\n";
     end);

  fprintf os "    _result = OE_OK;\n";
  fprintf os "done:\n";
  fprintf os "    if (_buffer)\n";
  fprintf os "        oe_free_ocall_buffer(_buffer);\n";
  fprintf os "    return _result;\n";
  fprintf os "}\n\n"

(** Generate ocall function table and registration *)
let oe_gen_ocall_table (os:out_channel) (ec:enclave_content) =
  fprintf os "\n/*ocall function table*/\n";
  fprintf os "static oe_ocall_func_t __%s_ocall_function_table[]= {\n" ec.enclave_name;
  List.iter (fun fd ->
      fprintf os "    (oe_ocall_func_t) ocall_%s,\n" fd.Ast.uf_fdecl.fname
    )  ec.ufunc_decls;
  fprintf os "    NULL\n";
  fprintf os "};\n\n"

(** Generate ocalls wrapper function *)
let oe_gen_ocall_host_wrapper (os:out_channel) (uf:Ast.untrusted_func) =
  let propagate_errno = uf.Ast.uf_propagate_errno in
  let fd = uf.Ast.uf_fdecl in
  fprintf os "void ocall_%s(\n" fd.Ast.fname;
  fprintf os "        uint8_t* input_buffer, size_t input_buffer_size,\n";
  fprintf os "        uint8_t* output_buffer, size_t output_buffer_size,\n";
  fprintf os "        size_t* output_bytes_written)\n";

  (* Variable declarations *)
  fprintf os "{\n";
  fprintf os "    oe_result_t _result = OE_FAILURE;\n";
  fprintf os "    OE_UNUSED(input_buffer_size);\n\n";
  fprintf os "    /* Prepare parameters */\n";
  fprintf os "    %s_args_t* pargs_in = (%s_args_t*) input_buffer;\n" fd.Ast.fname fd.Ast.fname;
  fprintf os "    %s_args_t* pargs_out = (%s_args_t*) output_buffer;\n\n" fd.Ast.fname fd.Ast.fname;
  fprintf os "    size_t input_buffer_offset = 0;\n";
  fprintf os "    size_t output_buffer_offset = 0;\n";
  fprintf os "    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));\n";
  fprintf os "    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));\n\n";

  (* Buffer validation *)
  fprintf os "    /* Make sure input and output buffers are valid */\n";
  fprintf os "    if (!input_buffer || !output_buffer) {\n";
  fprintf os "        _result = OE_INVALID_PARAMETER;\n";
  fprintf os "        goto done;\n\n";
  fprintf os "    }\n";

  (* Prepare in and in-out parameters *)
  fprintf os "    /* Set in and in-out pointers */\n";
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_chkptr then
          let size = oe_get_param_size (ptype, decl, "pargs_in->") in
          let tystr = get_cast_to_mem_type (ptype, decl) in
          match ptr_attr.Ast.pa_direction with
          | Ast.PtrIn -> fprintf os "    OE_SET_IN_POINTER(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | Ast.PtrInOut -> fprintf os "    OE_SET_IN_OUT_POINTER(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | _ -> ()
        else ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n";

  (* Prepare out and in-out parameters. The in-out parameter is copied to output buffer. *)
  fprintf os "    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */\n";
  List.iter (fun (ptype, decl) ->
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_chkptr then
          let size = oe_get_param_size (ptype, decl, "pargs_in->") in
          let tystr = get_cast_to_mem_type (ptype, decl) in
          match ptr_attr.Ast.pa_direction with
          | Ast.PtrOut -> fprintf os "    OE_SET_OUT_POINTER(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | Ast.PtrInOut -> fprintf os "    OE_COPY_AND_SET_IN_OUT_POINTER(%s, %s, %s);\n" decl.Ast.identifier size tystr
          | _ -> ()
        else ()
      | _ -> ()
    ) fd.Ast.plist;
  fprintf os "\n";

  (* Call the host function *)
  oe_gen_call_function os fd;

  (* Propagate errno *)
  (if propagate_errno then
     begin
       fprintf os "\n    /* Propagate errno */\n";
       fprintf os "    pargs_out->_ocall_errno = errno;\n";
     end);

  (* Mark call as success *)
  fprintf os "\n    /* Success. */\n";
  fprintf os "    _result = OE_OK;\n";
  fprintf os "    *output_bytes_written = output_buffer_offset;\n\n";
  fprintf os "done:\n";

  (* oe_gen_free_buffers os fd; *)
  fprintf os "    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))\n";
  fprintf os "        pargs_out->_result = _result;\n";
  fprintf os "}\n\n"

(** Check if any of the parameters or the return type has the given
    root type. *)
let uses_type (root_type:Ast.atype) (fd:Ast.func_decl) =
  let param_match =
    List.exists (fun (pt, decl) ->
        root_type =  (Ast.get_param_atype pt)
      ) fd.Ast.plist in
  if param_match then
    param_match
  else
    root_type = fd.Ast.rtype

let warn_non_portable_types (fd:Ast.func_decl) =
  let print_portability_warning ty =
    printf "Warning: Function '%s': %s has different sizes on Windows and Linux. \
            This enclave cannot be built in Linux and then safely loaded in Windows.\n"
      fd.fname ty
  in
  let print_portability_warning_with_recommendation ty recommendation =
    printf "Warning: Function '%s': %s has different sizes on Windows and Linux. \
            This enclave cannot be built in Linux and then safely loaded in Windows. \
            Consider using %s instead.\n"
      fd.fname ty recommendation
  in
  (* longs are represented as an Ast.Int type *)
  let long_t = Ast.Int { Ast.ia_signedness = Ast.Signed; Ast.ia_shortness = Ast.ILong} in
  let ulong_t = Ast.Int { Ast.ia_signedness = Ast.Unsigned; Ast.ia_shortness = Ast.ILong} in

  (if uses_type Ast.WChar fd then
     print_portability_warning "wchar_t");
  (if uses_type Ast.LDouble fd then
     print_portability_warning "long double");

  (* Handle long type *)
  (if uses_type (Ast.Long Ast.Signed) fd || uses_type long_t fd then
     print_portability_warning_with_recommendation "long" "int64_t or int32_t");

  (* Handle unsigned long type *)
  (if uses_type (Ast.Long Ast.Unsigned) fd || uses_type ulong_t fd then
     print_portability_warning_with_recommendation "unsigned long" "uint64_t or uint32_t")

let warn_signed_size_or_count_types (fd:Ast.func_decl) =
  let print_signedness_warning p =
    printf "Warning: Function '%s': Size or count parameter '%s' should not be signed.\n" fd.fname p
  in
  (* Get the names of all size and count parameters for the function [fd]. *)
  let size_params = List.map (fun (ptype, decl) ->
      (* The size may be either a [count] or [size], and then either a
         number or string. We are interested in the strings, as the
         indicate named [size] or [count] parameters. *)
      let param_name { ps_size; ps_count } =
        match ps_size, ps_count with
        (* [s] is the name of the parameter as a string. *)
        | (None, Some (Ast.AString s) | Some (Ast.AString s), None) -> s
        (* TODO: Check for [Some (Ast.ANumber n)] that [n > 0] *)
        | _ -> ""
      in
      (* Only variables that are pointers where [chkptr] is true may
         have size parameters. TODO: Validate this! *)
      match ptype with
      | Ast.PTPtr (atype, ptr_attr) when ptr_attr.Ast.pa_chkptr ->
        param_name ptr_attr.Ast.pa_size
      | _ -> ""
    ) fd.Ast.plist |> List.filter (fun x -> String.length x > 0) (* Remove the empty strings. *)
  in
  (* Print warnings for size parameters that are [Signed]. *)
  List.iter (fun (ptype, decl) ->
      (* TODO: Maybe make this a utility function. *)
      let get_int_signedness (i: Ast.int_attr) = i.Ast.ia_signedness in
      let name = decl.Ast.identifier in
      if List.mem name size_params then
        match ptype with
        (* TODO: Combine these two patterns. *)
        | Ast.PTVal (Ast.Long s | Ast.LLong s) when s = Ast.Signed -> print_signedness_warning name
        | Ast.PTVal (Ast.Int i) when get_int_signedness i = Ast.Signed -> print_signedness_warning name
        | _ -> ()
    ) fd.Ast.plist

let warn_size_and_count_params (fd:Ast.func_decl) =
  let print_size_and_count_warning { ps_size; ps_count } =
    match ps_size, ps_count with
        | Some (Ast.AString p), Some (Ast.AString q) ->
          failwithf "Function '%s': simultaneous 'size' and 'count' parameters '%s' and '%s' are not supported by oeedger8r.\n" fd.fname p q
        | _ -> ()
  in
  List.iter (fun (ptype, _) ->
      match ptype with
      | Ast.PTPtr (_, ptr_attr) when ptr_attr.Ast.pa_chkptr ->
        print_size_and_count_warning ptr_attr.Ast.pa_size
      | _ -> ()
    ) fd.Ast.plist

(** Validate Open Enclave supported EDL features. *)
let validate_oe_support (ec: enclave_content) (ep: edger8r_params) =
  (* check supported options *)
  if ep.use_prefix then failwithf "--use_prefix option is not supported by oeedger8r.";
  List.iter (fun f ->
      (if f.Ast.tf_is_priv then
         failwithf "Function '%s': 'private' specifier is not supported by oeedger8r" f.Ast.tf_fdecl.fname);
      (if f.Ast.tf_is_switchless then
         failwithf "Function '%s': switchless ecalls and ocalls are not yet supported by Open Enclave SDK." f.Ast.tf_fdecl.fname);
    ) ec.tfunc_decls;
  List.iter (fun f ->
      (if f.Ast.uf_fattr.fa_convention <> Ast.CC_NONE then
         let cconv_str = Ast.get_call_conv_str f.Ast.uf_fattr.Ast.fa_convention in
         printf "Warning: Function '%s': Calling convention '%s' for ocalls is not supported by oeedger8r.\n" f.Ast.uf_fdecl.fname cconv_str);
      (if f.Ast.uf_fattr.fa_dllimport then
         failwithf "Function '%s': dllimport is not supported by oeedger8r." f.Ast.uf_fdecl.fname);
      (if f.Ast.uf_allow_list != [] then
         printf "Warning: Function '%s': Reentrant ocalls are not supported by Open Enclave. Allow list ignored.\n" f.Ast.uf_fdecl.fname);
      (if f.Ast.uf_is_switchless then
         failwithf "Function '%s': switchless ecalls and ocalls are not yet supported by Open Enclave SDK." f.Ast.uf_fdecl.fname);
    ) ec.ufunc_decls;
  (* Map warning functions over trusted and untrusted function
     declarations *)
  let ufuncs = List.map (fun f -> (f.Ast.uf_fdecl)) ec.ufunc_decls in
  let tfuncs = List.map (fun f -> (f.Ast.tf_fdecl)) ec.tfunc_decls in
  let funcs = List.append ufuncs tfuncs in
  List.iter (fun f ->
      warn_non_portable_types f;
      warn_signed_size_or_count_types f;
      warn_size_and_count_params f;
    ) funcs

(** Includes are emitted in [args.h]. Imported functions have already
    been brought into function lists. *)
let gen_t_h (ec: enclave_content) (ep: edger8r_params) =
  let fname = ec.file_shortnm ^ "_t.h" in
  let guard = sprintf "EDGER8R_%s_T_H" (String.uppercase ec.file_shortnm) in
  let os = open_file fname ep.trusted_dir in
  fprintf os "#ifndef %s\n" guard;
  fprintf os "#define %s\n\n" guard;
  fprintf os "#include <openenclave/enclave.h>\n";
  fprintf os "#include \"%s_args.h\"\n\n" ec.file_shortnm;
  fprintf os "OE_EXTERNC_BEGIN\n\n";
  if ec.tfunc_decls <> [] then (
    fprintf os "/* List of ecalls */\n\n";
    List.iter (fun f -> fprintf os "%s;\n" (oe_gen_prototype f.Ast.tf_fdecl)) ec.tfunc_decls;
    fprintf os "\n");
  if ec.ufunc_decls <> [] then (
    fprintf os "/* List of ocalls */\n\n";
    List.iter (fun d -> fprintf os"%s;\n" (oe_gen_wrapper_prototype d.Ast.uf_fdecl false))  ec.ufunc_decls;
    fprintf os "\n");
  fprintf os "OE_EXTERNC_END\n\n";
  fprintf os "#endif // %s\n" guard;
  close_out os

let gen_t_c (ec: enclave_content) (ep: edger8r_params) =
  let ecalls_fname = ec.file_shortnm ^ "_t.c" in
  let os = open_file ecalls_fname ep.trusted_dir in
  fprintf os "#include \"%s_t.h\"\n" ec.file_shortnm;
  fprintf os "#include <openenclave/edger8r/enclave.h>\n";
  fprintf os "#include <stdlib.h>\n";
  fprintf os "#include <string.h>\n";
  fprintf os "#include <wchar.h>\n";
  fprintf os "\n";
  fprintf os "OE_EXTERNC_BEGIN\n\n";
  if ec.tfunc_decls <> [] then (
    oe_gen_ecall_functions os ec;
    oe_gen_ecall_table os ec);
  if ec.ufunc_decls <> [] then (
    fprintf os "\n/* ocall wrappers */\n\n";
    List.iter (fun d -> oe_gen_ocall_enclave_wrapper os d)  ec.ufunc_decls);
  fprintf os "OE_EXTERNC_END\n";
  close_out os

let oe_emit_create_enclave_decl (os:out_channel)  (ec:enclave_content) =
  fprintf os "oe_result_t oe_create_%s_enclave(const char* path,\n" ec.enclave_name;
  fprintf os "                                 oe_enclave_type_t type,\n";
  fprintf os "                                 uint32_t flags,\n";
  fprintf os "                                 const void* config,\n";
  fprintf os "                                 uint32_t config_size,\n";
  fprintf os "                                 oe_enclave_t** enclave);\n\n"

let oe_emit_create_enclave_defn (os:out_channel)  (ec:enclave_content) =
  fprintf os "oe_result_t oe_create_%s_enclave(const char* path,\n" ec.enclave_name;
  fprintf os "                                 oe_enclave_type_t type,\n";
  fprintf os "                                 uint32_t flags,\n";
  fprintf os "                                 const void* config,\n";
  fprintf os "                                 uint32_t config_size,\n";
  fprintf os "                                 oe_enclave_t** enclave)\n";
  fprintf os "{\n";
  fprintf os "    return oe_create_enclave(path,\n";
  fprintf os "               type,\n";
  fprintf os "               flags,\n";
  fprintf os "               config,\n";
  fprintf os "               config_size,\n";
  fprintf os "               __%s_ocall_function_table,\n" ec.enclave_name;
  fprintf os "               %d,\n" (List.length ec.ufunc_decls);
  fprintf os "               enclave);\n";
  fprintf os "}\n\n"

let gen_u_h (ec: enclave_content) (ep: edger8r_params) =
  let fname = ec.file_shortnm ^ "_u.h" in
  let guard = sprintf "EDGER8R_%s_U_H" (String.uppercase ec.file_shortnm) in
  let os = open_file fname ep.untrusted_dir in
  fprintf os "#ifndef %s\n" guard;
  fprintf os "#define %s\n\n" guard;
  fprintf os "#include <openenclave/host.h>\n";
  fprintf os "#include \"%s_args.h\"\n\n" ec.file_shortnm;
  fprintf os "OE_EXTERNC_BEGIN\n\n";
  oe_emit_create_enclave_decl os ec;
  if ec.tfunc_decls <> [] then (
    fprintf os "/* List of ecalls */\n\n";
    List.iter (fun f -> fprintf os "%s;\n" (oe_gen_wrapper_prototype f.Ast.tf_fdecl true)) ec.tfunc_decls;
    fprintf os "\n");
  if ec.ufunc_decls <> [] then (
    fprintf os "/* List of ocalls */\n\n";
    List.iter (fun d -> fprintf os"%s;\n" (oe_gen_prototype d.Ast.uf_fdecl))  ec.ufunc_decls;
    fprintf os "\n");
  fprintf os "OE_EXTERNC_END\n\n";
  fprintf os "#endif // %s\n" guard;
  close_out os

let gen_u_c (ec: enclave_content) (ep: edger8r_params) =
  let ecalls_fname = ec.file_shortnm ^ "_u.c" in
  let os = open_file ecalls_fname ep.untrusted_dir in
  fprintf os "#include \"%s_u.h\"\n" ec.file_shortnm;
  fprintf os "#include <openenclave/edger8r/host.h>\n";
  fprintf os "#include <stdlib.h>\n";
  fprintf os "#include <string.h>\n";
  fprintf os "#include <wchar.h>\n";
  fprintf os "\n";
  fprintf os "OE_EXTERNC_BEGIN\n\n";
  if ec.tfunc_decls <> [] then (
    fprintf os "/* Wrappers for ecalls */\n\n";
    List.iter (fun d -> oe_get_host_ecall_function os d.Ast.tf_fdecl; fprintf os "\n\n")  ec.tfunc_decls);
  if ec.ufunc_decls <> [] then (
    fprintf os "\n/* ocall functions */\n\n";
    List.iter (fun d -> oe_gen_ocall_host_wrapper os d) ec.ufunc_decls);
  oe_gen_ocall_table os ec;
  oe_emit_create_enclave_defn os ec;
  fprintf os "OE_EXTERNC_END\n";
  close_out os

(** Generate the Enclave code. *)
let gen_enclave_code (ec: enclave_content) (ep: edger8r_params) =
  validate_oe_support ec ep;

  if ep.gen_trusted then(
    oe_gen_args_header ec ep.trusted_dir;
    gen_t_h ec ep;
    if not ep.header_only then
      gen_t_c ec ep;
  );
  if ep.gen_untrusted then (
    oe_gen_args_header ec ep.untrusted_dir;
    gen_u_h ec ep;
    if not ep.header_only then
      gen_u_c ec ep;
  );
  printf "Success.\n"

(** Install the plugin. *)
let _ =
  Printf.printf "Generating edge routines for the Open Enclave SDK.\n";
  Plugin.instance.available <- true;
  Plugin.instance.gen_edge_routines <- gen_enclave_code;
