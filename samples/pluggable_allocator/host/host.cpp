// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <openenclave/host.h>
#include <stdio.h>
#include <chrono>
#include <thread>
#include <vector>

// Include the untrusted allocator_demo_u.h header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.
#include "allocator_demo_u.h"

using namespace std;
using namespace std::chrono;

static uint32_t _max_threads = 16;
static uint64_t _num_allocations = 100000;
static uint64_t _max_allocation_size = 16 * 1024;
static uint32_t _flags = OE_ENCLAVE_FLAG_DEBUG;

static void _print_usage_and_exit(const char* argv[])
{
    printf(
        "usage:\n"
        "    %s <default-enclave-path> <custom-enclave-path> "
        "[--simulate] "
        "[--num-allocations <value>] "
        "[--max-threads <value>]"
        "[--max-allocation-size <value>]\n",
        argv[0]);
    exit(1);
}

static void _parse_args(int argc, const char* argv[])
{
    if (argc < 3)
        _print_usage_and_exit(argv);

    int i = 3;
    while (i < argc)
    {
        const char* arg = argv[i++];
        if (strcmp(arg, "--simulate") == 0)
            _flags |= OE_ENCLAVE_FLAG_SIMULATE;
        else if (strcmp(arg, "--num-allocations") == 0)
        {
            if (i == argc)
                _print_usage_and_exit(argv);
            sscanf(argv[i++], "%lu", &_num_allocations);
        }
        else if (strcmp(arg, "--max-threads") == 0)
        {
            if (i == argc)
                _print_usage_and_exit(argv);
            sscanf(argv[i++], "%u", &_max_threads);
        }
        else if (strcmp(arg, "--max-allocation-size") == 0)
        {
            if (i == argc)
                _print_usage_and_exit(argv);
            sscanf(argv[i++], "%lu", &_max_allocation_size);
        }
        else
            _print_usage_and_exit(argv);
    }
}

static void _run_benchmark(
    const char* enclave_path,
    const char* allocator_name,
    uint64_t num_threads)
{
    oe_enclave_t* enclave = NULL;
    oe_result_t result;

    // Create the enclave
    result = oe_create_allocator_demo_enclave(
        enclave_path, OE_ENCLAVE_TYPE_AUTO, _flags, NULL, 0, &enclave);

    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "oe_create_alloctor_demo_enclave(): result=%u (%s)\n",
            result,
            oe_result_str(result));
        goto exit;
    }

    // Launch enclave threads that perform lots of memory allocations and
    // deallocations. Measure and print the elapsed time.
    {
        auto start_time = high_resolution_clock::now();
        vector<thread> threads(num_threads);
        for (size_t i = 0; i < threads.size(); ++i)
            threads[i] = std::thread([enclave]() {
                enclave_thread(enclave, _num_allocations, _max_allocation_size);
            });

        for (size_t i = 0; i < threads.size(); ++i)
            threads[i].join();
        auto end_time = high_resolution_clock::now();
        auto elapsed =
            duration_cast<milliseconds>(end_time - start_time).count();

        printf("    %32s = %4lu milliseconds\n", allocator_name, elapsed);
    }

exit:
    // Clean up the enclave if we created one
    if (enclave)
        oe_terminate_enclave(enclave);
    else
    {
        // Couldn't create enclave.
        fprintf(stderr, "Could not create enclave %s\n", enclave_path);
        abort();
    }
}

int main(int argc, const char* argv[])
{
    _parse_args(argc, argv);
    const char* mode =
        (_flags & OE_ENCLAVE_FLAG_SIMULATE) ? "simulation" : "hardware";
    printf("Configuration:\n");
    printf("    %32s = %s\n", "mode", mode);
    printf(
        "    %32s = %lu\n", "num-allocations (per-thread)", _num_allocations);
    printf(
        "    %32s = %lu bytes\n", "max-allocation-size", _max_allocation_size);

    for (uint32_t num_threads = 1; num_threads <= _max_threads;
         num_threads += 1)
    {
        printf("num-threads = %u:\n", num_threads);
        _run_benchmark(argv[1], "dlmalloc   (default allocator)", num_threads);
        _run_benchmark(
            argv[2], "oesnmalloc (pluggable allocator)", num_threads);
        printf("\n");
    }
}
